

# This file was *autogenerated* from the file Finite_Spaces/Presentations.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)#Basic functions related to presentations

def group_presentation(gens, rels):
    F = FreeGroup(gens)
    Gens = dict([(gens[i], F.gens()[i]) for i in range(len(gens))])
    Rels = []
    for r in rels:
        aux = F.one()
        for (g,e) in r:
            aux *= Gens[g]**e
        Rels.append(aux)
    presentation = F/Rels
    return presentation

def total_len_relator(G):
    return sum(sum(abs(e) for (l,e) in r.syllables()) for r in G.relations())

def inv(w):
    w.reverse()
    rels = [(u,-e) for u,e in w]
    return rels

def commutator(w1,w2):
    rels = w1 + w2 + inv(w1) + inv(w2)
    return rels

def conj(w1,w2):
    rels = w2 + w1 + inv(w2)
    return rels

#Poset associated to a group presentation

def aux_label(a, b, ind, c):
	return ('c' + str(a) + '_' + str(b) + ind + '_' + str(c))

def presentation_poset(gens,rels):
   
	#expanded relations
	Rels = []
	for i in range(len(rels)):
		Rels.append([])
		for l in rels[i]:
			if l[_sage_const_1 ] < _sage_const_0 :
				Rels[i] += [(l[_sage_const_0 ], -_sage_const_1 ) for k in range(abs(l[_sage_const_1 ]))]
			if l[_sage_const_1 ] > _sage_const_0 :
				Rels[i] += [(l[_sage_const_0 ], _sage_const_1 ) for k in range(abs(l[_sage_const_1 ]))]
	
	#V is the set of elements of the presentation poset
	V = list(range(len(rels)+_sage_const_1 )) + [x + str(i) for x in gens for i in range(_sage_const_1 ,_sage_const_4 )]
	
	#E is the list of cover relations of the presentaton poset
	E = []
	#edges associated to the generators
	for x in gens:
		E += [[_sage_const_0 , x +'2'], [_sage_const_0 , x +'3'], [x +'1', x +'2'], [x +'1', x +'3']]
	
	for i in range(len(Rels)):
		letters = {}
		for x in gens: letters[x] = _sage_const_0 
		for j in range(len(Rels[i])):
			letters[Rels[i][j][_sage_const_0 ]] = letters[Rels[i][j][_sage_const_0 ]] + abs(Rels[i][j][_sage_const_1 ])
		total_letters = sum([letters[x] for x in gens])

		V = V + [aux_label(i+_sage_const_1 , x, str(j), k) for x in gens if letters[x] != _sage_const_0  for j in range(_sage_const_1 , _sage_const_4 ) for k in range(_sage_const_1 , letters[x] + _sage_const_1 )] + [aux_label(i+_sage_const_1 , _sage_const_0 , '', k) for k in range(_sage_const_1 , total_letters + _sage_const_1 )]

		#the model of D^2 i associated to the cell corresponding to the relator i:
		
		#edges between the indicator i of the relator and the minimals of the cycle
		
		E = E + [[i+_sage_const_1 , aux_label(i+_sage_const_1 , _sage_const_0 , '', j+_sage_const_1 )] for j in range(total_letters)] + [[i+_sage_const_1 , aux_label(i+_sage_const_1 , x, '1', j+_sage_const_1 )] for x in gens for j in range(letters[x])]

		# edges between the models of S^1 associated to generators and relators
		
		for x in gens:
			for k in range(_sage_const_1 ,_sage_const_4 ):
				for j in range(letters[x]):
					E.append([x + str(k), aux_label(i+_sage_const_1 , x, str(k), j+_sage_const_1 )])
		for j in range(len(Rels[i])):
			E.append([_sage_const_0 , aux_label(i+_sage_const_1 , _sage_const_0 , '', j+_sage_const_1 )])
			#edges of the cycle which do not start in 0
		for l in Rels[i]:
			for j in range(letters[l[_sage_const_0 ]]):
				E += [[aux_label(i+_sage_const_1 , l[_sage_const_0 ], '1', j+_sage_const_1 ), aux_label(i+_sage_const_1 , l[_sage_const_0 ],'2', j+_sage_const_1 )],[aux_label(i+_sage_const_1 , l[_sage_const_0 ], '1', j+_sage_const_1 ),aux_label(i+_sage_const_1 , l[_sage_const_0 ], '3', j+_sage_const_1 )]]
			#edges of the cycle starting in 0
		cont = {}
		for x in gens: cont[x] = _sage_const_0 
		
		for j in range(len(Rels[i])):
			cont[Rels[i][j][_sage_const_0 ]] += _sage_const_1 
			
			#edges to the 'right'
			if Rels[i][j][_sage_const_1 ] > _sage_const_0 :
				E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', sum([cont[x] for x in gens])), aux_label(i+_sage_const_1 , Rels[i][j][_sage_const_0 ], '2', cont[Rels[i][j][_sage_const_0 ]])])
			else:
				E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', sum([cont[x] for x in gens])), aux_label(i+_sage_const_1 , Rels[i][j][_sage_const_0 ], '3', cont[Rels[i][j][_sage_const_0 ]])])
			#edges to the 'left'
			if j != _sage_const_0 :
				if Rels[i][j-_sage_const_1 ][_sage_const_0 ] == Rels[i][j][_sage_const_0 ]:
					if Rels[i][j-_sage_const_1 ][_sage_const_1 ] > _sage_const_0 :
						E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', sum([cont[x] for x in gens])), aux_label(i+_sage_const_1 , Rels[i][j-_sage_const_1 ][_sage_const_0 ], '3', cont[Rels[i][j-_sage_const_1 ][_sage_const_0 ]]-_sage_const_1 )])
					else:
						E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', sum([cont[x] for x in gens])), aux_label(i+_sage_const_1 ,Rels[i][j-_sage_const_1 ][_sage_const_0 ], '2', cont[Rels[i][j-_sage_const_1 ][_sage_const_0 ]]-_sage_const_1 ) ]) 
				else:
					if Rels[i][j-_sage_const_1 ][_sage_const_1 ] > _sage_const_0 :
						E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', sum([cont[x] for x in gens])), aux_label(i+_sage_const_1 ,Rels[i][j-_sage_const_1 ][_sage_const_0 ], '3', cont[Rels[i][j-_sage_const_1 ][_sage_const_0 ]])])
					else:
						E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', sum([cont[x] for x in gens])), aux_label(i+_sage_const_1 ,Rels[i][j-_sage_const_1 ][_sage_const_0 ], '2', cont[Rels[i][j-_sage_const_1 ][_sage_const_0 ]]) ])
		
		#j=0
		n = len(Rels[i]) - _sage_const_1 
		if Rels[i][n][_sage_const_1 ] > _sage_const_0 :
			E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', _sage_const_1 ), aux_label(i+_sage_const_1 , Rels[i][n][_sage_const_0 ], '3', cont[Rels[i][n][_sage_const_0 ]])])
		else:
			E.append([aux_label(i+_sage_const_1 , _sage_const_0 , '', _sage_const_1 ), aux_label(i+_sage_const_1 , Rels[i][n][_sage_const_0 ], '2', cont[Rels[i][n][_sage_const_0 ]])])

	return Poset((V, E))

